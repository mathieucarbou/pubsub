{"name":"Mycila PubSub","tagline":"EventBus system for publish and subscribe to events within an application","body":"**Table of Contents**\r\n\r\n- [Mycila PubSub](#mycila-pubsub)\r\n\t- [Maven Repository](#maven-repository)\r\n\t- [Documentation](#documentation)\r\n\t\t- [Sample](#sample)\r\n\t\t- [Usage](#usage)\r\n\t\t\t- [Subscribing](#subscribing)\r\n\t\t\t- [Publishing](#publishing)\r\n\t\t\t- [Synchronous requests](#synchronous-requests)\r\n\t\t\t- [Asynchronous requests](#asynchronous-requests)\r\n\t\t\t- [Request answers](#request-answers)\r\n\t\t- [Features](#features)\r\n\t\t\t- [Topics and Event types](#topics-and-event-types)\r\n\t\t\t- [In-Memory event system](#in-memory-event-system)\r\n\t\t\t- [Memory management](#memory-management)\r\n\t\t\t- [Exception handling](#exception-handling)\r\n\t\t\t- [Topic Matchers](#topic-matchers)\r\n\t\t\t- [Annotation support](#annotation-support)\r\n\t\t\t\t- [Subscribers](#subscribers)\r\n\t\t\t\t- [Publisher](#publisher)\r\n\t\t\t\t- [Requests](#requests)\r\n\t\t\t\t- [Answering requests](#answering-requests)\r\n\t\t\t- [Event dispatching strategies](#event-dispatching-strategies)\r\n\t\t\t\t- [Synchronous Safe Dispatching](#synchronous-safe-dispatching)\r\n\t\t\t\t- [Synchronous Unsafe Dispatching](#synchronous-unsafe-dispatching)\r\n\t\t\t\t- [Asynchronous Safe Dispatching](#asynchronous-safe-dispatching)\r\n\t\t\t\t- [Asynchronous Unsafe Dispatching](#asynchronous-unsafe-dispatching)\r\n\t\t\t\t- [Broadcast Ordered Dispatching](#broadcast-ordered-dispatching)\r\n\t\t\t\t- [Broadcast Unordered Dispatching](#broadcast-unordered-dispatching)\r\n\t\t\t\t- [Custom strategy](#custom-strategy)\r\n\t\t\t- [Integration](#integration)\r\n\t\t\t\t- [Google Guice](#google-guice)\r\n\r\n# Mycila PubSub #\r\n\r\nMycila Event is a new powerful event framework for in-memory event management. It has a lot of features similar to [EventBus](https://eventbus.dev.java.net/) but is better written and uses Java Concurrency features to provide you with:\r\n\r\n * Asynchronous event dispatching\r\n * Multicasting events\r\n * Topic matchers: enable a subscriber (and a vetoers) to subscribe to many topics\r\n * Annotation support: you can annotate your methods to decouple your code from Mycila Event and subscribe, publish and veto\r\n * Memory management through hard and weak references\r\n\r\n__Project Status:__\r\n\r\n - __OSGI Compliant:__ <img width=\"100px\" src=\"http://www.sonatype.com/system/images/W1siZiIsIjIwMTMvMDQvMTIvMTEvNDAvMzcvMTgzL05leHVzX0ZlYXR1cmVfTWF0cml4X29zZ2lfbG9nby5wbmciXV0/Nexus-Feature-Matrix-osgi-logo.png\" title=\"OSGI Compliant\"></img>\r\n - __Build Status:__ [![Build Status](https://travis-ci.org/mycila/pubsub.png?branch=master)](https://travis-ci.org/mycila/pubsub)\r\n - __Issues:__ https://github.com/mycila/pubsub/issues\r\n\r\n## Maven Repository ##\r\n\r\n__Releases__\r\n\r\nAvailable in Maven Central Repository: http://repo1.maven.org/maven2/com/mycila/pubsub/\r\n\r\n__Snapshots__\r\n \r\nAvailable in OSS Repository:  https://oss.sonatype.org/content/repositories/snapshots/com/mycila/pubsub/\r\n\r\n__Maven dependency__\r\n\r\n    <dependency>\r\n        <groupId>com.mycila</groupId>\r\n        <artifactId>mycila-pubsub</artifactId>\r\n        <version>X.Y.ga</version>\r\n    </dependency>\r\n\r\n__Maven sites__\r\n\r\n - [5.0.ga](http://mycila.github.io/pubsub/reports/5.0.ga/index.html)\r\n\r\n## Documentation ##\r\n\r\nMycila Event is a new powerful event framework for in-memory event management. It has a lot of features similar to [EventBus](https://eventbus.dev.java.net/) but is better designed, uses Java Concurrency features and has a lot of more event features than EventBus, which are really useful when you work with a complex system driven by event messaging.\r\n\r\n### Sample ###\r\n\r\n    import static com.mycila.event.api.topic.Topics.*;\r\n    \r\n    // first create an event service\r\n    Dispatcher dispatcher = Dispatchers.synchronousSafe(ErrorHandlers.rethrowErrorsAfterPublish());\r\n    \r\n    // then subscribe\r\n    TopicMatcher matcher = only(\"app/events/swing/button\").or(topics(\"app/events/swing/fields/**\"));\r\n    dispatcher.subscribe(matcher, String.class, new Subscriber<String>() {\r\n        public void onEvent(Event<String> event) throws Exception {\r\n            System.out.println(\"Received: \" + event.source());\r\n        }\r\n    });\r\n    \r\n    // and publish\r\n    dispatcher.publish(topic(\"app/events/swing/button\"), \"Hello !\");\r\n\r\nWhen you subscribe, you need to give to which topic to subscribe and for which event type.\r\n\r\n### Usage ###\r\n\r\n#### Subscribing ####\r\n\r\nSubscribing is done with the Dispatcher.subscribe method, which take the topic to subscribe to, the event type and an instance of `Subscriber<T>`, where T is the event type. The method receives an Event object, containing the timestamp (in nanoseconds) and the source.\r\n\r\n__Example:__\r\n\r\n    dispatcher.subscribe(only(\"prog/events/a\").or(matching(\"prog/events/b/**\")), String.class, new Subscriber<String>() {\r\n        public void onEvent(Event<String> event) throws Exception {\r\n            sequence.add(event.getSource());\r\n        }\r\n    });\r\n\r\n#### Publishing ####\r\n\r\nPublishing is done by simply sending to a topic an event object.\r\n\r\n    dispatcher.publish(topic(\"prog/events/a\"), \"Hello for a\");\r\n\r\n#### Synchronous requests ####\r\n\r\nAn event system is asynchronous by default, but you sometimes need to wait for an answer before proceeding. This is the request/response pattern that everyone know. You can create a request and wait for its response (or wait with a timeout). The request is created through `Messages.createRequest`, where you can pass request parameters. The you call `MessageRequest.getResponse()` to obtain the response.\r\n\r\n    MessageRequest<Integer> adddRequest = Messages.createRequest(new int[]{1, 2, 3, 4, 5}, \"param2\");\r\n    dispatcher.publish(topic(\"system/add\"), adddRequest);\r\n    int sum = adddRequest.getResponse(1, TimeUnit.SECOND);\r\n\r\n#### Asynchronous requests ####\r\n\r\nYou can also request in asynchronous mode by adding listeners, which will be triggered when the response will be received;\r\n\r\n    MessageRequest<Integer> adddRequest = Messages.createRequest(new int[]{1, 2, 3, 4, 5}, \"param2\");\r\n    adddRequest.addListener(new MessageListener<Integer>() {\r\n        public void onResponse(Integer value) {\r\n            assertEquals(15, value.intValue());\r\n        }\r\n    \r\n        public void onError(Throwable t) {\r\n            t.printStackTrace();\r\n            fail();\r\n        }\r\n    });\r\n    dispatcher.publish(topic(\"system/add\"), adddRequest);\r\n\r\n#### Request answers ####\r\n\r\nTo be able to respond to an answer on a topic, you simply have to subscribe, with the specific event type `MessageResponse`:\r\n\r\n    dispatcher.subscribe(only(\"system/add\"), MessageResponse.class, new Subscriber<MessageResponse<Integer>>() {\r\n        public void onEvent(Event<MessageResponse<Integer>> event) throws Exception {\r\n            int[] p = (int[]) event.getSource().getParameters()[0];\r\n            System.out.printl(event.getSource().getParameters()[1]); // output the second parameter\r\n            int c = 0;\r\n            for (int i : p) c += i;\r\n            event.getSource.reply(c);\r\n        }\r\n    });\r\n\r\nThe event type is a special class which enable to take the parameters and reply a response. You could also respond by an exception if an error occured in the subscriber:\r\n\r\n    event.getSource().replyError(new ArithmeticException(\"Overflow !\"));\r\n\r\n### Features ###\r\n\r\n#### Topics and Event types ####\r\n\r\nWhen you subscribe, you subscribe in a Topic for a given event type. Event type subclasses are allowed to be received by a subscriber accepting its super-class. In example, if you subscribe to `Topic.topic(\"buttons/ok\")` with event type `ActionListener.class`, you can publish any implementation of `ActionListener` and it will be received by subscribers accepting the type (and sub-types) `ActionListener`.\r\n\r\n#### In-Memory event system ####\r\n\r\nMycila Event is not a JMS solution ! Like EventBus, Mycila Event resolves intra-process communication. In example, it can be used in a Swing GUI or in a complex modular framework to handle communication between plugins.\r\n\r\nThus, __Mycila Event must be fast, thread-safe and scalable.__\r\n\r\n#### Memory management ####\r\n\r\nLike EventBus, Mycila Event supports *hard and weak subscriptions*. A hard subscription will always remain and must be unregistered if not needed anymore. A weak subscription will be automatically removed when the subscriber is no longer in use.\r\n\r\nBy default, if nothing is specified, Mycila Event uses a hard reference. this is very useful when you simply bind a listener like this:\r\n\r\n    dispatcher.subscribe(matcher, String.class, new Subscriber<String>() {\r\n        public void onEvent(Event<String> event) throws Exception {\r\n            System.out.println(\"Received: \" + event.source());\r\n        }\r\n    });\r\n\r\nReachability control can be done by annotating the class with `@Reference`. In example, suppose you have a plugin class subscribing for events. You can annotate the class like this:\r\n\r\n    @Reference(Reachability.WEAK)\r\n    public class MyPlugin implements Subscriber<String> {\r\n        public void onEvent(Event<String> event) throws Exception {\r\n            System.out.println(\"Received: \" + event.source());\r\n        }\r\n        public void start() {\r\n            // start the plugin\r\n        }\r\n    }\r\n    \r\n    MyPlugin pluginLoadedByAnotherSystem = ...;\r\n    dispatcher.subscribe(matcher, String.class, pluginLoadedByAnotherSystem);\r\n\r\nWhen registering the plugin, a weak registration will be done so that if the plugin is unloaded or not used anymore, the subscription could be removed automatically.\r\n\r\n`@Reference` can also be put on methods, when used with annotations.\r\n\r\n#### Exception handling ####\r\n\r\nBy default, if a subscriber launches an exception, the exception is rethrown immediately, in the thread firering the event. You can change this behavior by providing your own `ErrorHandler`, or by using existing one:\r\n\r\n - `ErrorHandlers.ignoreErrors()`: ignore all exceptions thrown by subscribers\r\n - `ErrorHandlers.rethrow()`: the default behavior.\r\n\r\nTo create an Dispatcher with the appropriate event handler, you just have to set the `ErrorHandler` instance when creating it:\r\n\r\n    Dispatcher dispatcher = Dispatchers.synchronousSafe(ErrorHandlers.ignoreErrors());\r\n\r\n#### Topic Matchers ####\r\n\r\nWhen you register a subscriber, you need to pass the type of event you want to receive and a matcher to math topics you want to listen to. TopicMatcher can be created with the `Topics` class. You can compose matchers.\r\n\r\n * `Topics.only(exactName)`: matches a single topic name. *Example:* `Topics.only(\"app/events/buttons/ok\")`\r\n * `Topics.topics(pattern)`: matches several topic by using an Ant expression. *Example:* `Topics.topics(\"app/events/buttons/**\")`\r\n * `Topics.any()`: matches any topic\r\n * `Topics.not(matcher)`: invert the given matcher\r\n * `matcher.and(matcher)`: any matcher can be composed with another matcher with an *and*. In this case, all matchers must match given topic event for the subscriber to receive it. This is quite an uncommon case.\r\n * `matcher.or(matcher)`: any matcher can be composed with another matcher with an *or*. In this case, the subscriber will receive events matching the two matchers. This is a common case where you would like to receive in one subscriber the same events from different topics.\r\n\r\nIn example, to set a catch-all subscriber, you could do:\r\n\r\n    dispatcher.subscribe(Topics.any(), Object.class, new Subscriber<Object>() {\r\n        public void onEvent(Event<Object> event) throws Exception {\r\n            System.out.println(\"Received: \" + event.source());\r\n        }\r\n    });\r\n\r\n#### Annotation support ####\r\n\r\nMycila Event provides annotations to create publishers and subscribers decoupled from the Dispatcher service.\r\n\r\n##### Subscribers #####\r\n\r\nYou can annotate any method in your class to receive events with the `@Subscribe` annotation. It takes in arguments the list of topics (an Ant expression matching topics) to listen to and the type of event.\r\n\r\nThese annotations must be placed on methods having one parameter: `Event` for listening to events.\r\n\r\nYou can use the `@Reference` annotation to control if the listeners is weak or not. This annotation can be place on the method, or, if you have in your class several annotated methods to listen for events, you can place the `@Reference` annotation in the class directly.\r\n\r\n___By default, a subscription has a HARD reference. So be VERY CAREFUL when you register listeners implemented by your classes to make them WEAK if they have a shorter lifecycle than the Dispatcher.___\r\n\r\n__Subscribe to events__\r\n\r\n    class MyClass1 {\r\n        @Subscribe(topics = \"prog/events/a/**\", eventType = String.class)\r\n        private void handle(Event<String> event) {\r\n            // do something\r\n        }\r\n    }\r\n\r\nIn your code, after having created a `Dispatcher`, you can use the `AnnotationProcessors` to register annotated methods like this:\r\n\r\n    MyClass1 c1 = new ...\r\n    \r\n    AnnotationProcessor processor = AnnotationProcessors.create(dispatcher);\r\n    processor.process(c1);;\r\n\r\n##### Publisher #####\r\n\r\nPublishers can be created using the annotation `@Publish`. You can completely decouple your code by creating interface (or abstract classes) that will be automatically generated thanks to annotations.\r\n\r\nIn example:\r\n\r\n    private static interface B {\r\n        @Publish(topics = \"prog/events/a\")\r\n        void send(String a, int b);\r\n    }\r\n    \r\n    static abstract class C {\r\n        @Publish(topics = {\"prog/events/a/a1\", \"prog/events/a/allA\"})\r\n        abstract void send(String a, int b);\r\n    }\r\n\r\nThese two classes defines publishing methods. B will publish two events (a string and an integer) to one topic, and C will publish two events in two topics.\r\n\r\nTo automatically generate their implementation, you can use, after having created a Dispacther:\r\n\r\n    B b = annotationProcessor.proxy(B.class);\r\n    C c = annotationProcessor.proxy(C.class);\r\n    \r\n    b.send(\"Hello for a\", 1);\r\n    c.send(\"Hello for a1\", 4);\r\n\r\nB and C are classes in your code that you can use directly to publish events.\r\n\r\nYou can annotate a generated Publisher method by `@Multiple`. If the publishing method is given an array or collection of objects, each object will be published independently as an event.\r\n\r\nIn example:\r\n\r\n    abstract class MyCustomPublisher2 {\r\n        @Publish(topics = \"a/topic/path\")\r\n        @Multiple\r\n        abstract void send(int event1, String... otherEvents);\r\n    }\r\n    [...]\r\n    myCustomPublisher2.send(1, \"each\", \"string\", \"will\", \"be\", \"an\", \"event\")\r\n\r\n__Note__: you can then create abstract classes which act sa event managers: abstract methods annotated by @Publish will be generated and concrete methods annotated by @Subscribe will receive events.\r\n\r\n##### Requests #####\r\n\r\nRequesting methods acts the same as publishers. They differ in the annotation, which provides a way to timeout and wait for the response to come back. In example, suppose you have an additioner plugin exposing its computation method to the topic `system/add`. You can create a subscriber like this:\r\n\r\n    interface Requestor {\r\n        @Request(topic = \"system/add\", timeout = 1, unit = TimeUnit.SECONDS)\r\n        int addNumbers(int... p);\r\n    }\r\n    Dispatcher dispatcher = Dispatchers.synchronousSafe();\r\n    AnnotationProcessor processor = AnnotationProcessors.create(dispatcher);\r\n    Requestor req = processor.proxy(Requestor.class);\r\n    assertEquals(15, req.addNumbers(1,2,3,4,5));\r\n\r\nGiven the nature of a method call, it is obvious that the call is synchronous and will wait either indefinitely for a response or only with the given time.\r\n\r\n##### Answering requests #####\r\n\r\nThere is two way for answering requests: as we seen, we have to register a simple subscriber. It can be done like this:\r\n\r\n    static class DU {\r\n        @Subscribe(topics = \"system/du\", eventType = MessageResponse.class)\r\n        void duRequest(Event<MessageResponse<Integer>> event) {\r\n            String folder = (String) event.getSource().getParameters()[0];\r\n            System.out.println(\"du request on folder \" + folder);\r\n            // call du -h <folder>\r\n            if (\"notFound\".equals(folder))\r\n                event.getSource().replyError(new FileNotFoundException(\"du did not found folder \" + folder));\r\n            else\r\n                event.getSource().reply(40);\r\n        }\r\n    }\r\n    Dispatcher dispatcher = Dispatchers.synchronousSafe();\r\n    AnnotationProcessor processor = AnnotationProcessors.create(dispatcher);\r\n    DU du = new DU();\r\n    processor.process(du);\r\n\r\nHopefully, there is a better way. The request sends as parameter a String, and the subscriber replies with an integer. So what if we can simply call a method ? This can be done like this:\r\n\r\n    static class DU {\r\n        @Answers(topics = \"system/du\")\r\n        int getSize(String folder) throws FileNotFoundException {\r\n            System.out.println(\"du request on folder \" + folder);\r\n            // call du -h <folder>\r\n            if (\"notFound\".equals(folder))\r\n                throw new FileNotFoundException(\"du did not found folder \" + folder);\r\n            return 40;\r\n        }\r\n    }\r\n    Dispatcher dispatcher = Dispatchers.synchronousSafe();\r\n    AnnotationProcessor processor = AnnotationProcessors.create(dispatcher);\r\n    DU du = new DU();\r\n    processor.process(du);\r\n\r\nThe method output (or the exception) will then be used as the reply if an request is made to the topic `system/du`.\r\n\r\n#### Event dispatching strategies ####\r\n\r\nThere are several strategies regarding about how you want the order of events and the order of listeners be respected and whether or not you have multiple threads publishing events.\r\n\r\n##### Synchronous Safe Dispatching #####\r\n\r\n * Listeners are called in the order they subscribed\r\n * Events are published __one after one__\r\n * Only one thread can publish at a time\r\n\r\nThis strategy guarantees the order of listeners called and that only one thread will hit the listeners at a time. Thus, your listeners don't need to be thread-safe. The publish method thus block until the previous publishing is finished.\r\n\r\nThis behavior allows you to have stateful non thread-safe subscribers. When multiple threads are publishing, this strategy is slower.\r\n\r\n    Dispatcher dispatcher = Dispatchers.synchronousSafe();\r\n\r\n##### Synchronous Unsafe Dispatching #####\r\n\r\n * Listeners are called in the order they subscribed\r\n * Events are published immediately\r\n * Several threads can publish at a time\r\n\r\nThis strategy guarantees the order of listeners called. The publish method only block for the current thread, meaning that a thread can be publishing while another thread also starting publishing an event. Thus, your subscribers can be hit at the same time by two or more threads.\r\n\r\nYour subscribers need to be stateless and thread-safe. Multiple threads can publish at the same time.\r\n\r\n    Dispatcher dispatcher = Dispatchers.synchronousUnsafe();\r\n\r\n##### Asynchronous Safe Dispatching #####\r\n\r\n * Listeners are called in the order they subscribed\r\n * Events are published one after one\r\n * Many threads can enqueue an event at one time\r\n * One background thread is responsible to dequeue and fire events\r\n * A queue is used to enqueue events before they are processed.\r\n\r\nThis strategy guarantees the order of listeners called and the order of published events. The publish method *does not block* and the publisher thread immediately returns. The event is queued and wait for its turn to be processed by the background thread.\r\n\r\nThis strategy is useful when your publishers must execute as fast as possible, but be careful to also have fast subscribers to not fill the queue. This behavior allows you to have stateful non thread-safe subscribers since only one thread will dequeue and fire events.\r\n\r\nSince this strategy uses an unbounded queue, be careful to have fast subscribers and to not publish events more than your subscribers can consume.\r\n\r\n    Dispatcher dispatcher = Dispatchers.asynchronousSafe();\r\n\r\n##### Asynchronous Unsafe Dispatching #####\r\n\r\n * Listeners are called in the order they subscribed\r\n * Several events (so listeners) are processed at the same time\r\n * Many threads can publish an event at one time\r\n * Several background threads are responsible for firing events\r\n\r\nThis strategy guarantees the order of listeners called, but not the order of event. Basically, each call to publish will return immediately. All events in the queue are handled by a thread pool.\r\n\r\nThis strategy is useful when your publishers must execute as fast as possible, and event publishing needs to be processed quickly, but by respecting listener order. This dispatcher can be seen as a concurrent event dispatcher, respecting listener order.\r\n\r\nSince this strategy uses an unbounded queue, be careful to have fast subscribers and to not publish events more than your subscribers can consume.\r\n\r\nYour subscribers need to be stateless and thread-safe. Multiple threads can send events at the same time.\r\n\r\n    Dispatcher dispatcher = Dispatchers.asynchronousUnsafe();\r\n\r\n##### Broadcast Ordered Dispatching #####\r\n\r\n * Listeners are called unordered\r\n * Events are published one after one\r\n * Many threads can enqueue an event at one time\r\n * A thread-pool is used to send each event to each subscriber\r\n\r\nThis strategy guarantees the order of events but calls listeners unordered. The goal of a broadcasting is to reach as fast as possible each listeners in the smallest amount of time. A thread-pool is used to handle subscriber's execution.\r\n\r\nThis type of dispatching is really useful when you don't care about ordering and want to publish fast and want your subscribers to be called as fast as possible.\r\n\r\nNote that when a thread publishes an event, it is enqueued. A thread is used to enqueue events one per one and fire this event concurrently to all subscribers. The publish method returns immediately, but for another event to be processed, all concurrent firing of the previous event must have finished.\r\n\r\nThis guarantees that all subscribers will be called concurrently, but they will all receive the events in the same order.\r\n\r\n    Dispatcher dispatcher = Dispatchers.broadcastOrdered();\r\n\r\n##### Broadcast Unordered Dispatching #####\r\n\r\n * Listeners are called unordered\r\n * Several events are published at the same time\r\n * Many threads can enqueue an event at one time\r\n * A thread-pool is used to send each event to each subscriber\r\n\r\nThis type of dispatching is really useful when you don't care about any ordering. Since the publish method does not block, any thread will be able to publish events really fast and a thread-pool is used to process them all, unordered.\r\n\r\nThus, subscribers taking a long time to execute don't affect publishing of other events to other subscribers.\r\n\r\n    Dispatcher dispatcher = Dispatchers.broadcastUnordered();\r\n\r\n##### Custom strategy #####\r\n\r\nYou can easily implelement and control your own dispatching strategy: simply look at the source code of `Dispatchers` to have more example. You can create a custom dispacther like this:\r\n\r\n    Dispatcher dispatcher = Dispatchers.custom(errorHandlerProvider, publishingExecutor, subscriberExecutor);\r\n\r\nExecutors are implementations of `java.util.concurrent.Executor`. The first one control the concurrency of the whole publishing process and the second one control the concurrency for calling a subscriber. The class `com.mycila.event.util.Executors` has two flavors that can help you for basic cases: \r\n\r\n * `Executors.immediate()`: execute the runnable immediately\r\n * `Executors.blocking()`: idem, but blocks so that only one thread can execute a subscriber at a time\r\n\r\n#### Integration ####\r\n\r\n##### Google Guice #####\r\n\r\nhttp://code.google.com/p/google-guice/\r\n\r\nMycila Event can be used without any IOC. But thanks to the powerful annotation support and injection listeners of [http://code.google.com/p/google-guice/ Google Guice], this dependency injection library integrates very well with Mycila Event.\r\n\r\n__Binding generated publishers__\r\n\r\n    public final class MyModule implements Module {\r\n        @Override\r\n        public void configure(Binder binder) {\r\n            MycilaEventGuice.bindPublisher(binder, MyCustomPublisher.class).in(Singleton.class);\r\n            MycilaEventGuice.bindPublisher(binder, MyCustomPublisher2.class).in(Singleton.class);\r\n            MycilaEventGuice.bindPublisher(binder, MyCustomPublisher3.class).in(Singleton.class);\r\n        }\r\n    \r\n        @Reference(Reachability.WEAK)\r\n        static interface MyCustomPublisher {\r\n            @Publish(topics = \"a/topic/path\")\r\n            void send(String... messages);\r\n        }\r\n    \r\n        static abstract class MyCustomPublisher2 {\r\n            @Publish(topics = \"a/topic/path\")\r\n            @Multiple\r\n            abstract void send(int event1, String... otherEvents);\r\n        }\r\n    \r\n        static abstract class MyCustomPublisher3 {\r\n            @Publish(topics = \"a/topic/path\")\r\n            @Multiple\r\n            abstract void send(int event1, Iterable<String> events);\r\n        }\r\n    }\r\n    \r\n    injector.getInstance(MyCustomPublisher.class).send(\"A\", \"cut\", \"message\", \"containing\", \"bad words\");\r\n    injector.getInstance(MyCustomPublisher2.class).send(1, \"A\", \"cut\", \"message\", \"containing\", \"bad words\", \"in varg\");\r\n    injector.getInstance(MyCustomPublisher3.class).send(1, Arrays.asList(\"A\", \"cut\", \"message\", \"containing\", \"bad words\", \"in list\"));\r\n\r\n__Automatically inject publishers and create subscriptions__\r\n\r\nSuppose you have a class like this:\r\n\r\n    public final class MyImpl implements MyClass {\r\n    \r\n        Publisher<String> publisher;\r\n    \r\n        @Subscribe(topics = \"a/topic/path\", eventType = String.class)\r\n        void subscribe(Event<String> event) {\r\n            System.out.println(\"(subscribe) Got: \" + event);\r\n        }\r\n    \r\n        @Subscribe(topics = \"a/topic/path\", eventType = String[].class)\r\n        void subscribeToList(Event<String[]> event) {\r\n            System.out.println(\"(subscribeToList) Got: \" + Arrays.toString(event.source()));\r\n        }\r\n    \r\n        @Subscribe(topics = \"a/topic/path\", eventType = Integer.class)\r\n        void subscribeToInts(Event<Integer> event) {\r\n            System.out.println(\"(subscribeToInts) Got: \" + event.source());\r\n        }\r\n    \r\n        @Publish(topics = \"a/topic/path\")\r\n        void publisher(Publisher<String> publisher) {\r\n            System.out.println(\"Publisher injected\");\r\n            publisher.publish(\"Hello from publisher !\");\r\n            this.publisher = publisher;\r\n        }\r\n    }\r\n\r\nWhen configuring Guice, simply put MycileEventModule like this:\r\n\r\n    Injector injector = Guice.createInjector(new MycilaEventGuiceModule(), new AbstractModule() {\r\n    \t@Override\r\n    \tpublic void configure(Binder binder) {\r\n    \t\tbinder.bind(MyClass.class).to(MyImpl.class);\r\n    \t}        \r\n    });\r\n\r\nAll the created instances by Guice will automatically discover MycilaEvent annotations and subscribing methods will be registered and publishers will be injected.\r\n\r\n[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/caad3334753cab502059a0ff8483e382 \"githalytics.com\")](http://githalytics.com/mycila/pubsub)\r\n","google":"UA-5669052-12","note":"Don't delete this file! It's used internally to help with page regeneration."}